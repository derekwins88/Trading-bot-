
using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Text.Json;
using System.Text.RegularExpressions;
using System.IO.Compression;

namespace SymbolicTrading.Storage
{
    // This class bundles JSON-based capsules into a compressed "crystal" archive.
    // Capsules are expected to be produced by other modules into the `config/Capsules` directory
    // (for example strategy engines persisting trade outcomes as JSON capsules).
    // Each capsule JSON should match the CapsuleHeader schema consumed below.
    // The compressor reads these files and produces a `.crystalbundle` that includes
    // an index file describing contents and annotations extracted from source JSON.
    // It relies on `System.Text.Json` for serialization and `System.IO.Compression`
    // for creating the archive.
    public class MemoryCrystalCompressor
    {
        // Name of the index file inside bundles
        internal const string IndexFileName = "@index.crystal";
        private const string BundleExtension = ".crystalbundle";
        
        public void CompressCapsules(string sourceDir, string outputPath, string bundleName)
        {
            // Ensure output directory exists
            Directory.CreateDirectory(Path.GetDirectoryName(outputPath));
            
            // Create temporary bundle structure
            var bundleDir = Path.Combine(Path.GetTempPath(), Guid.NewGuid().ToString());
            Directory.CreateDirectory(bundleDir);
            
            try
            {
                // Process capsule files (.json files typically generated by data ingestion components)
                var capsuleFiles = Directory.GetFiles(sourceDir, "*.json");
                var indexEntries = new List<CrystalIndexEntry>();
                
                foreach (var file in capsuleFiles)
                {
                    // Read and analyze capsule
                    var capsuleContent = File.ReadAllText(file);
                    var capsule = JsonSerializer.Deserialize<CapsuleHeader>(capsuleContent);
                    var annotations = ExtractAnnotations(capsuleContent);
                    
                    // Build index entry for this capsule
                    var entry = new CrystalIndexEntry
                    {
                        Id = capsule.capsule_id,
                        Timestamp = capsule.timestamp,
                        Origin = capsule.origin,
                        Symbols = capsule.axiom_lineage.Select(a => a.Split('â‡Œ').Last()).Distinct().ToArray(),
                        Annotations = annotations,
                        FileName = Path.GetFileName(file)
                    };
                    indexEntries.Add(entry);
                    
                    // Copy file into bundle directory
                    File.Copy(file, Path.Combine(bundleDir, Path.GetFileName(file)));
                }
                
                // Write index file describing all capsules
                var indexFilePath = Path.Combine(bundleDir, IndexFileName);
                File.WriteAllText(indexFilePath, JsonSerializer.Serialize(indexEntries));
                
                // Compress bundle into final archive
                var bundlePath = Path.Combine(outputPath, $"{bundleName}{BundleExtension}");
                ZipFile.CreateFromDirectory(bundleDir, bundlePath);

                Console.WriteLine($"ðŸŒ€ Created crystal bundle: {bundlePath} ({capsuleFiles.Length} capsules)");
            }
            finally
            {
                // Cleanup temporary directory
                Directory.Delete(bundleDir, true);
            }
        }

        public CrystalBundle OpenBundle(string bundlePath)
        {
            if (!File.Exists(bundlePath))
                throw new FileNotFoundException("Crystal bundle not found", bundlePath);
                
            return new CrystalBundle(bundlePath);
        }

        private List<string> ExtractAnnotations(string jsonContent)
        {
            var annotations = new List<string>();
            
            // Collect `// @memo:` style annotations from the JSON capsule
            var matches = Regex.Matches(jsonContent, @"//\s*@memo:\s*(.+?)\n");
            foreach (Match match in matches)
            {
                if (match.Success && match.Groups.Count > 1)
                    annotations.Add(match.Groups[1].Value.Trim());
            }
            return annotations;
        }

        // Header representation loaded from capsule JSON files
        private class CapsuleHeader
        {
            public string capsule_id { get; set; }
            public DateTime timestamp { get; set; }
            public string origin { get; set; }
            public string[] axiom_lineage { get; set; }
        }
    }

    // Entry describing a capsule inside a bundle. Useful for searching.
    public class CrystalIndexEntry
    {
        public string Id { get; set; }
        public DateTime Timestamp { get; set; }
        public string Origin { get; set; }
        public string[] Symbols { get; set; }
        public List<string> Annotations { get; set; }
        public string FileName { get; set; }
    }

    // Represents an opened bundle that can query capsules without extracting everything.
    public class CrystalBundle : IDisposable
    {
        private readonly string _tempDir;
        private readonly List<CrystalIndexEntry> _index;
        
        public string BundlePath { get; }
        public IReadOnlyList<CrystalIndexEntry> Index => _index.AsReadOnly();

        public CrystalBundle(string bundlePath)
        {
            BundlePath = bundlePath;
            _tempDir = Path.Combine(Path.GetTempPath(), Guid.NewGuid().ToString());
            
            // Extract bundle contents to a temporary directory
            ZipFile.ExtractToDirectory(bundlePath, _tempDir);
            
            // Read the index generated by MemoryCrystalCompressor
            var indexPath = Path.Combine(_tempDir, MemoryCrystalCompressor.IndexFileName);
            var indexContent = File.ReadAllText(indexPath);
            _index = JsonSerializer.Deserialize<List<CrystalIndexEntry>>(indexContent);
        }

        public string GetCapsuleContent(string id)
        {
            var entry = _index.FirstOrDefault(e => e.Id == id);
            if (entry == null) return null;
            
            var filePath = Path.Combine(_tempDir, entry.FileName);
            return File.Exists(filePath) ? File.ReadAllText(filePath) : null;
        }

        public List<CrystalIndexEntry> Search(string query)
        {
            return _index.Where(e => 
                e.Id.Contains(query, StringComparison.OrdinalIgnoreCase) ||
                e.Origin.Contains(query, StringComparison.OrdinalIgnoreCase) ||
                e.Symbols.Any(s => s.Contains(query, StringComparison.OrdinalIgnoreCase)) ||
                e.Annotations.Any(a => a.Contains(query, StringComparison.OrdinalIgnoreCase)))
                .ToList();
        }

        public void Dispose()
        {
            try { Directory.Delete(_tempDir, true); }
            catch { /* Ignore cleanup errors */ }
        }
    }
}
